/*****************************************************************************
*
* Universal Tensor Network Library
*
* Copyright (C) 2013-2014 
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT 
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE 
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, 
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
* DEALINGS IN THE SOFTWARE.
*
* Please direct any enquiry to <development@uni10.org>
*
*****************************************************************************/

#ifndef UNI10_DATATYPE_QNUM_H
#define UNI10_DATATYPE_QNUM_H

#include <iostream>
#include <iomanip>
#include <cassert>

namespace uni10 {
namespace datatype {

//using namespace std;   // We never want to impose the user to use the std namespace...

//const int U1_UPB = 100;	//Upper bound of U1      // Comment: It is not a good practice to declare like this. Think OOP...
//const int U1_LOB = -100;//Lower bound of U1
//const int prt_UPB = 2;  //Upper bound of prt
//const int prt_LOB = -1; //Lower bound of prt

template <class I, class S>
class Qnum 
{
public:
  // typedefs
  typedef I  int_type;    // to be replaced by template...
  typedef S  short_type;

  // Non-standard constructor
  Qnum
    ( int_type U1_   = int_type()
    , int_type prt_  = int_type()
    );

  // I/O
  int_type U1()  const  { return _U1; }
  int_type prt() const  { return _ptr; } 

  int_type get_U1()  const  { return U1(); }    // to be depreciated...
  int_type get_ptr() const  { return ptr(); }   // to be depreciated...

  void set_U1  (int_type U1_);
  void set_ptr (int_type ptr_);
  void set     (int_type U1_=int_type(), int_type ptr_=int_type());   // to be depreciated...

  template<class I1, class S1>
  Qnum& operator=(const Qnum<I1,S1>& obj);  


/*
		Qnum_t(): U1(0), prt(0){}

		Qnum_t(int _U1): U1(_U1), prt(0){
			assert(U1 < U1_UPB && U1 > U1_LOB);
		}

		Qnum_t(int _U1, int _prt): U1(_U1), prt(_prt){
			assert(U1 < U1_UPB && U1 > U1_LOB && prt < prt_UPB && prt > prt_LOB);
		}
*/
		//Qnum_t(const Qnum_t& _q):U1(_q.U1), prt(_q.prt){}  // Redundant: Copy constructors are automatically generated by compilers...

		//~Qnum_t(){};  // Redundant: Empty destructors are automatically generated by compilers... 


//		friend bool operator< (const Qnum_t& q1, const Qnum_t& q2);   // redundant
//		friend bool operator<= (const Qnum_t& q1, const Qnum_t& q2);  // redundant
//		friend bool operator== (const Qnum_t& q1, const Qnum_t& q2);  // redundant

//		friend Qnum_t operator- (const Qnum_t& q1);    // subtraction is free function
//		friend Qnum_t operator* (const Qnum_t& q1, const Qnum_t& q2);  // multiplication should be free function...

    template <class I1, class S1>
		friend std::ostream& operator<< (std::ostream& os, const Qnum<I1,S1> & q);

private:
  short_type  _prt;
  int_type    _U1;

  static const int_type  U1_UPB;      // this should be made nicer...
  static const int_type  U1_LOB;      // ....
  static const int_type  ptr_UPB;
  static const int_type  ptr_LOB;
};

} // ending namespace datatype
} // ending namespace uni10

#endif
