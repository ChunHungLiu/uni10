/*****************************************************************************
*
* Universal Tensor Network Library
*
* Copyright (C) 2013-2014 
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT 
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE 
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, 
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
* DEALINGS IN THE SOFTWARE.
*
* Please direct any enquiry to <development@uni10.org>
*
*****************************************************************************/

#ifndef UNI10_DATATYPE_QNUM_H
#define UNI10_DATATYPE_QNUM_H

#include <iostream>
#include <iomanip>
#include <cassert>

namespace uni10 {
namespace datatype {

//using namespace std;   // We never want to impose the user to use the std namespace...

//const int U1_UPB = 100;	//Upper bound of U1      // Comment: It is not a good practice to declare like this. Think OOP...
//const int U1_LOB = -100;//Lower bound of U1
//const int prt_UPB = 2;  //Upper bound of prt
//const int prt_LOB = -1; //Lower bound of prt

//template <class I>
class Qnum 
{
public:
  // typedefs
  typedef int  int_type;    // to be replaced by template...

  // Non-standard constructor
  Qnum
    ( int_type U1_   = int_type()
    , int_type prt_  = int_type()
    );

  // 
  int_type U1() const  { return _U1; }
  int_type prt() const { return _ptr; } 

  int_type getU1() const { return U1(); }    // to be depreciated...
  int_type getptr() const { return ptr(); }  // to be depreciated...

  void setU1(int_type U1_)
  void 


/*
		Qnum_t(): U1(0), prt(0){}

		Qnum_t(int _U1): U1(_U1), prt(0){
			assert(U1 < U1_UPB && U1 > U1_LOB);
		}

		Qnum_t(int _U1, int _prt): U1(_U1), prt(_prt){
			assert(U1 < U1_UPB && U1 > U1_LOB && prt < prt_UPB && prt > prt_LOB);
		}
*/
		//Qnum_t(const Qnum_t& _q):U1(_q.U1), prt(_q.prt){}  // Redundant: Copy constructors are automatically generated by compilers...

		//~Qnum_t(){};  // Redundant: Empty destructors are automatically generated by compilers... 



		void set(int _U1 = 0, int _prt = 0);

		friend bool operator< (const Qnum_t& q1, const Qnum_t& q2);
		friend bool operator<= (const Qnum_t& q1, const Qnum_t& q2);
		friend bool operator== (const Qnum_t& q1, const Qnum_t& q2);

		friend Qnum_t operator- (const Qnum_t& q1);    // subtraction is free function
		friend Qnum_t operator* (const Qnum_t& q1, const Qnum_t& q2);  // multiplication should be free function...

		friend ostream& operator<< (ostream& os, const Qnum_t& q);

private:
  char      _prt;
  int_type  _U1;

  static const int U1_UPB = 100;
  static const int U1_LOB = -100;
  static const int ptr_UPB = 2;
  static const int ptr_LOB = -1;
};

} // ending namespace datatype
} // ending namespace uni10

